# よく間違える問題

1. 下記コードの実行結果として正しい組み合わせを選択肢の中から選べ。

    ```
    0x65.chr(Encoding::UTF_8)
    => "e"
   
    chrメソッドは文字コードに対応する文字を求めるメソッド。
    0x65.chrは"e"となるが65.chrは"A"となる点に注意。
    ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   cooking = "Rice\nBread\rPasta\n\r"
   p cooking.chomp
   => "Rice\nBread\rPasta\n"
   
   chompメソッドは、末尾から指定した文字列（指定がなければ改行コード"\r", "\r\n", "\n"）を取り除いた文字列を返す。
   ここでは、末尾が"\r\n"ではなく、"\n\r"なので、末尾の"\r"のみが取り除かれる。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   ```
   music = "Jazz\nRock\rTechno\n\r!"
   music.chop
   p music
   
   #=> "Jazz\nRock\rTechno\n\r!"
   chopメソッドは非破壊的メソッドなので、ひっかけ問題。
   ```

1. 下記コードの実行結果を、選択肢の中から選べ。
   
   ```
   ef.downto(ab){|s| print(s)}
   => エラーになる
   
   downtoメソッドは文字列に使用するとエラーになる。
   数値や日付などに使用可能。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   pass = [8, 9, 2, 1] | [2, 7, 4, 1].sort
   p pass
   => [8, 9, 2, 1, 4, 7]
   
   sortメソッドは、配列の内容をソートする。今回は[2, 7, 4, 1].sortのみがソートされ、
   [8, 9, 2, 1] | [1, 2, 4, 7]となる。
   その後、パイプ演算子によって、重複排除されるため、[8, 9, 2, 1, 4, 7]となる。
   ```

1. 下記コードの実行結果を、選択肢の中から選べ。
   
   ```
   i = 10.upto(20).reject {|d| d >= 15 }
   print i
   => [10, 11, 12, 13, 14]
   
   rejectメソッドはブロックを評価した結果が偽である要素を含む配列を返す。
   今回は、10~20の間で、15以上でない数字[10, 11, 12, 13, 14]が配列として返る。
   逆に、selectメソッドにした場合は、評価した結果が真である要素を含む配列を返すため、
   [15, 16, 17, 18, 19, 20]が返る。
   ```

1. File.openのmodeについて正しい説明をしている選択肢を選べ。
   
   ```
   => "a"は書き込み専用。ファイルが存在しない場合、新規作成する。
   File.openメソッドでファイルを開く。
   引数でファイルを開くモードを設定できる。
   
   "r"・・・read 読み込みモード。
   "w"・・・write　書き込みモード。既存ファイルの場合はファイルの内容を空にする。
   "a"・・・append　追記モード。常にファイルの末尾に追加される。
   "r+"・・・読み書きモード。ファイルの読み書き位置は先頭にセットされる。
   "w+"・・・読み書きモード。既存ファイルの場合はファイルの内容を空にする。
   "a+"・・・読み書きモード。ファイルの読み込み位置は先頭にセットされるが、書き込みは常にファイルの末尾に追加される。
   ```

1. 下記コードを実行した際の戻り値を選べ。
   
   ```
   id = [1, 2, 3, 4, 5]
   p id.delete(3)
   => 3
   
   deleteメソッドは指定された値と==メソッドで等しい値があれば全て取り除いて、その値を返す。
   取り除いた配列を返すわけではないので注意！
   なければnilを返す。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   h = {:name => 'sato', :club => 'tennis'}.fetch(:name, 'error')
   print h
   => sato
   
   fetchメソッドは与えられたキーに対する値を返す。
   今回はnameがキーとなる値 'sato'を返す。
   2番目の引数に指定されている 'error'は該当するキーがない場合の返り値となる。今回はキーがあるため、ひっかけなので注意。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   （１）p sprintf("%#b", 20)
   （２）p sprintf("%#o", 20)
   （３）p sprintf("%#x", 20)
   => （１）"0b10100"（２）"024"（３）"0x14"
   
   組み込み関数sprintfでフォーマットの指定ができる。
   第一引数でフォーマット、第二引数でフォーマットしたい値を指定する。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   a = ["fire", "water", "wind"]
   b = a.clone
   c = a
   a.concat(["metal"])
   
   （１）a == b
   （２）a == c
   => （１）false （２）true
   
   a = ["fire", "water", "wind"]
   b = a.clone  
   # この時点で b = ["fire", "water", "wind"]
   c = a
   # この時点で c = ["fire", "water", "wind"]
   a.concat(["metal"])
   # この時点で a = ["fire", "water", "wind", "metal"]
   # 同時に c = ["fire", "water", "wind", "metal"] に変わる。
   
   評価前のa,b,c各変数の要素を整理すると以下となる。
   a = ["fire", "water", "wind", "metal"]
   b = ["fire", "water", "wind"]
   c = ["fire", "water", "wind", "metal"]
   
   よって、結果は以下となる。
   a == b # false
   a == c # true
   ```

1. 戻り値が「Object」以外となるコードを選択肢の中から選べ。
   
   ```
   => puts Integer.superclass # Numeric となる
   
   superclassメソッドを使うことで、継承元のクラスを確認できる。
   String, Array, HashはObjectクラスを継承しているが、
   IntegerとFloatはNumericクラスという数値を表現するクラスを継承している。
   
   Integer.superclass # Numeric
   Float.superclass # Numeric
   String.superclass # Object
   Array.superclass # Object
   Hash.superclass # Object
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   Curry = "udon"
   Curry << "rice"
   p Curry
   => 警告は出ず、"udonrice"と出力される。
   
   定数を再代入するときは警告が出るが、<<メソッドで連結するときは警告は出ないので注意！
   ```
   
1. includeの説明として正しいものを選択肢の中から選べ。
   
   ```
   => Moduleクラスのメソッドである
   
   includeメソッドを使用することで、生成したモジュールオブジェクトをクラスに取り込むことができる。
   ```
 
 1. 例外処理の説明として誤っているものを選択肢の中から選べ。
    
    ```
    def exam
      begin
        （１）例外が発生する可能性のある処理
      rescue 
        （２）例外が発生した場合の処理
      else
        （３）正常の処理
      ensure
        （４）例外発生の有無にかかわらず行う処理
      end
    end
    => （３）にraiseを記入することで、強制的に例外を発生させることができる。
    
    raiseで例外を発生させることができるが、（１）の箇所で例外を発生させるべきである。
    ```
    
 1. 下記コードを実行した結果、エラーが発生するものを選べ。
    
    ```
    => meibo = {:Name => Sato, :Class => 1-1, :ID => 1}
    
    値であるSatoを""（ダブルクォーテーション）で囲んでいないのでエラーとなる。
    ```

1. 下記コードを実行した際の戻り値を選べ。
   
   ```
   singer=["shintani", "kamiya"]
   p singer.shift
   => "shintani"
   
   shiftメソッドは先頭から指定された数だけ要素を取り除いて返す。指定がなければ先頭の要素を返す。
   取り除かれた後の配列ではなく、取り除かれた要素の値を返すので注意！
   ```
   
1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   a = "victory"
   b = "victory"
   c = a
   
   （１）p a.eql?(b)
   （２）p a.eql?(c)
   （３）p a.equal?(b)
   （４）p a.equal?(c)
   正解: （１）true （２）true （３）false （４）true
   
   eql?メソッドとequal?メソッドの違いの問題。
   eql?メソッドは同値性を判定。値と型が等しければtrueを返し、異なればfalseを返す。
   equal?メソッドは同一性を判定。2つのオブジェクトが同一かどうかを判定し、等しければtrue, 異なればfalseを返す。
   ```

1. Rubyの予約語として適切な物を選びなさい。（２つ選択）

    ```
    1. while
    2. rand
    3. goto
    4. class
    5. const
    
    正解: 1,4
    Rubyの予約語
        BEGIN   class       ensure  nil     self    when
        END     def         false   not     super   while
        alias   defined?    for     or      then    yield
        and     do          if      redo    true    __LINE__
        begin   else        in      rescue  undef   __FILE__
        break   elsif       module  retry   unless  __ENCODING__
        case    end         next    return  until
    それ以外・・・rand, goto, const 
    ```

1. 以下のコードを実行するとどうなりますか？
    
    ```
    x = 0
    [1,2,3].each do |x|
        print x.to_s + " "
    end
    puts x
    
    => 1,2,3,0
    1行目の宣言している変数xとeachブロックの変数xはスコープが異なるため、別の変数として扱われる。
    ```

1. 以下のコードを実行するとどうなりますか？最も適切な記述を選びなさい。

    ```
    HOGE = "hoge"
    HOGE.gsub!("hoge", "piyo")
    print HOGE
    
    #=> 警告は発生せず、「piyo」が表示される
    HOGEは定数だが、警告が発生するのは、新たに代入するときのみ。
    ここでは破壊的メソッドを呼び出しているだけなので、警告は発生しない。
    ```

1. 以下のコードのxに、ZeroDivisionErrorが発生した時の処理を記述したい。適切なコードを選びなさい。

    ```
    begin
        puts 10 / 0 #ZeroDivisionError
        x
        print "ZeroDivisionException:", ex.message
    end
    
    結果： ZeroDivisionException:divided by 0
    
    #=> rescue ZeroDivisionError => ex 
    rescue節は、rescue【例外型】=>【例外変数】と記述します。
    begn節で【例外型】の例外が発生した場合、【例外変数】には例外オブジェクトへの参照が渡され、処理される。
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを選びなさい。

    ```
    s = "a;b:c;d:e;f"
    p s.split(x)
    
    結果： ["a", "b", "c", "d", "e", "f"]
    
    #=> /:|;/
    String#splitは引数で指定された正規表現などで文字列を分割し、配列に格納する。
    正規表現はスラッシュでパターンを囲む。スラッシュの前後にダブルクォーテーションは付かないので注意！
    ```

1. 以下のコードの実行結果として適切なものを選びなさい。
    
    ```
    a = [1,2,3,4]
    b = [1,3,5,7]
    
    p a || b
    
    #=> [1,2,3,4]
    演算子||は、真であるオペランドの値を返す。
    左オペランドの評価結果が真の場合は、右オペランドを評価せずに左オペランドの値を返す。
    今回はnilでもfalseでもないので、左オペランド部が真となるため、値[1,2,3,4]を返す。
    ```

1. 以下のコードの実行結果として適切な物を選びなさい。
    
    ```
    a = [:a, :a, :b, :c]
    a[5] = :e
    a.concat([:a, :b, :c])
    a.compact
    a.uniq
    p a
   
    #=> [:a, :a, :b, :c, nil, :e, :a, :b, :c]
    Array#concatは配列を連結する。
    compactはnil要素を削除する。
    uniqは重複している要素を削除する。
    ただし、compactとuniqは**非破壊的メソッド**なのでオブジェクトの値は変更しない。
    ```

1. Arrayクラスでdetectと同じ動作をするメソッドを選びなさい。
    
    ```
    #=> find
    detectとfindは各要素に対してブロックを評価し、真になった最初の要素を返す。
    # 最初の 3 の倍数を探す
    p [1, 2, 3, 4, 5].find {|i| i % 3 == 0 }   # => 3
    p [2, 2, 2, 2, 2].find {|i| i % 3 == 0 }   # => nil
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを**全て**選びなさい。
    
    ```
    a = ["a", "b", "c"]
    b = [1, 2, 3]
    x
   
    結果： ["a", 1]
          ["b", 2]
          ["c", 3]
   
    #=> a.zip(b).each{|x| p x}
        a.zip(b){|x| p x}
        [a, b].transpose.each{|x, y| p [x, y]}
        
        Array#zipは自身と引数に渡した配列の各要素からなる配列を生成して返す。
        ブロックを渡した場合は、各要素を順番に返す。
        Array#transposeは2次元配列の行と列を入れ替えるメソッド。
    ```

1. 以下のコードの実行結果として適切な物を選びなさい。
    
    ```
    x = "Hello, World.\n"
    x.chop
    x.chop
    x.chomp
    p x
    
    #=> "Hello, World.\n"
    String#chopは末尾の1文字を削除する。
    String#chompは末尾が行区切り文字であれば削除する。
    今回は、どちらも**非破壊的メソッド**なので、元の文字列は変更しない。 
    ```

1. 以下のコードを実行すると何が表示されますか？
    
    ```
    puts "0123456789-".delete("^13-56-")
    
    #=> 13456-
    String#deleteは、引数に含まれる文字を文字列から取り除く。
    ^で始まる文字列は、その文字列以外を削除する。
    deleteメソッドは削除する文字列を返す。 
    ```

1. 以下のコードを実行すると何が表示されますか？
    
    ```
    p "abc def 123 ghi 456".scan(/\d+/).length
    
    #=> 2
    String#scanは正規表現にマッチする部分文字列を配列で返す。
    \d+は数字の繰り返し。
    ```

1. 以下のコードを実行するとどうなりますか。
    
    ```
    h = {"a": 1, "b": 2, "c": 3}
    p h
    
    #=> 文法エラーになる
    Ruby2.1ではキーの部分を文字列リテラルで表記することはできず、文法エラーになる。
    Ruby2.2からはこの書き方でハッシュを生成できる。
    ```

1. 以下のコードを実行すると何が表示されますか。
    
    ```
    a = {"Foo" => "Hoge", "Bar" => "piyo", "Baz" => "Fuga"}
    b = {"Foo" => "hoge", "Bar" => "piyo", "Baz" => "fuga"}
    
    p a.update(b).sort{|a, b| a[1] <=> b[1]}
   
    #=> [["Baz", "fuga"], ["Foo", "hoge"], ["Bar", "piyo"]]
    Hash#updateメソッドは、自分自身のHashと引数に指定したHashを統合する。
    そのため、4行目直後の状態は{"Foo" => "hoge", "Bar" => "piyo", "Baz" => "fuga"}となる。
    sortメソッドのブロック内のa[1] <=> b[1]はHashの各ペア（[キー、値]）を値の昇順に並べるので、
    [["Baz", "fuga"], ["Foo", "hoge"], ["Bar", "piyo"]]になる。
    ```
   
1. 以下のコードは、ファイルtest.txtを読み、文字を逆順に書き込む処理です。xに入る適切な記述を選びなさい。
    
    ```
    open("test.txt"," x ") do |f|
        data = f.read.chomp
        data.reverse!
        f.rewind
        f.write data
    end
    
    #=> r+
    組み込み関数openの第2引数でファイルのopenモードを指定する。
    r,w,aに+を付けると、読み書き両用でオープンする。w+に指定すると元のファイルの内容を空にする。
    a+を指定すると、追記モードになる。
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを選びなさい。

    ```
    puts File. x ("/","user","bin")
   
    結果： /user/bin
    
    #=> join
    joinはスラッシュを間に入れて引数の文字列を連結したファイルパスを作成する。
    ```

1. Rubyの組み込み定数（プログラム実行時に既に値が格納されている定数）として正しいものを選択してください。

    ```
    ARGV
    RUBY_ENV
    LOAD_PATH
    OS
    
    #=> ARGV
    組み込み定数ARGVにはRubyスクリプトに与えられた引数が配列として格納される。 
    ```

1. 以下の正規表現にマッチする文字列として正しいものを選択肢から選んでください。
   
   【正規表現】
   
   /\A\d{3}-\d{4}\z/
   
   ```
   (a) 690-0x23
   (b) foo@example.com
   (c) 690-0823
   (d) PCODE690-0823
   
   #=> (c)
   「\A」は文字列先頭、「\z」は文字列末尾を表す。
   「\d{3}」は、0～9のうちいずれか1文字が3文字連続し、「\d{4}」は0～9のうちいずれか1文字が4文字連続することを意味する。
   ```

1. 以下のコードの(A)に入れて実行した出力結果として、文字列オブジェクトを3文字ごとに分割した各要素を持つ配列オブジェクトを返すものを選択肢の中から選択してください。

   出力結果:
   
   ["abc", "def", "ghi", "jkl", "mno", "pqr", "stu", "vwx"]
   
   ```
   (a) split(//, 3)
   (b) gsub(/.{3}/) {|s| s.upcase }
   (c) scan(/.{3}/)
   (d) match(/.{3}/)
   
   #=> (c)
   scanメソッドはレシーバに指定された文字列オブジェクトが、引数に指定されたパターンにマッチするかを繰り返し確かめ、マッチした文字列を要素とした配列オブジェクトを返す。
   .は任意の文字列にマッチすることを意味し、{3}は{}の直前にある.が3文字並んでいるときにマッチする。
   ```

1. 以下のコードを実行した出力結果として正しいものを選択肢の中から選択してください。
    
    ```
    str = "foobarbaz\r\n\r\n"
    p str.chomp('').chop.chop.reverse
    ```
    
    ```
    (a) “\n\r\n\rzabrabo”
    (b) “braboof”
    (c) “\n\r\n\rzabraboof”
    (d) “abraboof”
   
    #=> (b)
    文字列strはまずchompメソッドを呼び出す。chompメソッドはレシーバに指定した文字列オブジェクトから取り除きたい改行コードを引数に指定できる。
    ただし、空文字列を引数に指定した場合はレシーバに指定した文字列オブジェクトの文末の改行コードをすべて取り除いた新しい文字列を返す。
    そのため、文末に改行コードがあった"foobarbaz\r\n\r\n"から"foobarbaz"になる。
    次にchompメソッドが返した"foobarbaz"の文字列オブジェクトがchopメソッドを呼び出します。
    chopメソッドはレシーバに指定した文字列オブジェクトの文末に改行コードがなければ、文末から1文字取り除いた新しい文字列を返す。
    このchopメソッドが2回呼び出されているため、chompメソッドが返した"foobarbaz"から"foobarb"になる。
    ```

1. 以下のコードを実行した出力結果として正しいものを選択肢の中から選択してください。
    
    ```
    ary = [1,2,3,4,5,6]
    p ary.inject {|a, b| a + b}
    
    #=> 21
    injectメソッドに引数を指定しない場合は、レシーバの配列の先頭の要素と2番目の要素をブロックに渡して実行する。
    2回目以降は前回ブロックを実行した結果と次の要素をブロックに渡して実行する。
    ```

1. 以下のコードの(A)に選択肢を入れて実行した時に出力結果が同じになるものを選択肢の中から選択してください。
   
    ```
    hash = {:foo => 1, :bar => 2}
    p hash.(A)
   
    (a) find {|i| i.member?(:foo)}
    (b) delete(:foo)
    (c) reject {|key, value| key == :foo }
    (d) dup
   
    #=> (b)
    deleteメソッドは引数のキーとレシーバのキーが同じなら、レシーバのハッシュオブジェクトの要素を削除し、削除した要素の値を返す。
    rejectメソッドはレシーバに指定したハッシュオブジェクトを複製し、複製したハッシュオブジェクトの要素のキーと値をブロックに渡し、
    ブロックで評価した結果が死んであった要素を全て取り除いたハッシュオブジェクトを返す。 今回の場合は、{:bar => 2}を返すため不正解。
    findメソッドはブロックで評価した結果が真であった最初の要素の配列オブジェクトを返す。member?メソッドは引数に指定した(:foo)が要素に含まれている場合に真を返す。
    よって今回の場合findメソッドは[:foo, 1]を返すため不正解。
    dupメソッドはレシーバに指定したハッシュオブジェクトを複製して返す。
    ```

1. 以下のコードの(A)に入れて実行した出力結果として、barを返すものを選択肢の中から選択してください。
    
    ```
    module Foo
      Bar = "bar"
    end
     
    class Baz
      include Foo
    end
     
    puts (A)  #=> bar

    選択肢   
    (a) Baz::Bar
    (b) Bar
    (c) Foo::Baz::Bar
    (d) Baz::Foo::Bar
   
    #=> (a)
    クラスの定義の中でincludeメソッドを使用することによって、引数に指定したモジュールのインスタンスメソッド、インスタンス変数、定数の情報を定義しているクラスに追加します。
    問題ではBazクラスにFooモジュールをインクルードすることによって定数のBarが追加されます。
    文字列オブジェクトの"bar"が代入されている定数のBarは、FooモジュールとBazクラスのどちらかを参照することで返されるようになりました。
    クラスやモジュールの中に定義した定数を参照するには::演算子を使用します。そのため、Fooクラスの定数のBarを参照するにはFoo::Barもしくは::Foo::Barになります。
    Bazクラスの中にインクルードされた定数のBarを参照するのはBaz::Barか::Baz::Barです。
    そのため、(a)が正解です。他の選択肢は別の定数を参照しようとしています。
    ```
   
1. 以下のコードの(A)に入れて実行した出力結果として、fooを返すものを選択肢の中から選択してください。
    
    ```
    class Object
      def foo
        puts "foo"
      end
    end
     
    (A)
   
    選択肢
    (a) self.foo
    (b) Object::foo
    (c) foo
    (d) Object.foo
   
    #=> (c) foo
    Rubyのプログラムが始まると、mainと呼ばれるObjectクラスのインスタンスの中にいます。
    そのため、Objectクラスを拡張してインスタンスメソッドを定義すると、定義したメソッドをトップレベルで呼び出せます。
    そのため、(b)以外は特異メソッドの呼び出しの形式だから(b)が正解です。
    ```
   
1. 以下のコードを実行した出力結果として正しいものを選択肢の中から選択してください。

    ```
    class Foo
      @@count = 0
     
      def count
        @@count
      end
     
      def increment
        @@count += 1
      end
    end
     
    class Bar < Foo; end
    class Baz < Bar; end
     
    baz = Baz.new
    baz.increment
    bar = Bar.new
    bar.increment
    foo = Foo.new
    p foo.count
   
    選択肢
    (a) 1
    (b) 0
    (c) 2 
    (d) 3
   
    #=> (c) 2
    Fooクラスで定義している@@countはクラス変数です。
    クラス変数は@@で始まる変数であり、クラス変数を定義したクラスとそのクラスを継承したサブクラスで定義したメソッドの中で参照と代入をおこなえます。
    問題はFooクラスの中で@@countに0を代入しています。
    @@countを定義したFooクラスはBarに継承され、BarクラスはBazクラスに継承しています。
    BarクラスとBazクラスのどちらもFooクラスと継承関係にあり、継承したincrementメソッドを呼び出すごとに@@countに代入している数値オブジェクトを1ずつ加算していきます。そのため、incrementメソッドを呼び出している回数だけ@@countに代入している数値オブジェクトの値が加算されます。incrementメソッドを呼び出している回数は2回です。つまり@@countの数値オブジェクトには2が代入されています。
    そのため、(c)が正解です。
    ```
   
1. 以下のコードを実行した出力結果として正しいものを選択肢の中から選択してください。

    ```
    Foo = "main"
     
    class Bar
      Foo = "foo"
     
      def self.foo
        ::Foo
      end
    end
     
    p Bar.foo
   
    選択肢
    (a) “foo”
    (b) nil
    (c) “warning: already initialized constant Foo”が標準エラーに出力される
    (d) “main”
   
    #=> (d) "main"
    Barクラスで定義しているクラスメソッドのfooメソッドは::Fooという名前の定数を返します。
    Fooという名前の定数はトップレベルに定義されているのと、Barクラスの中で定義している定数の2つです。
    この2つは別の定数なので、(d)の定数へもう一度代入した時の警告は出力されません。
    そして、nilを代入している定数のFooはないので、(c)のnilは正解ではありません。
    fooメソッドが返す::Fooのような::演算子から始まる定数は、トップレベルで定義されている定数です。
    問題のトップレベルで定義されているFooという名前の定数は、"main"を代入している定数です。
    そのため、fooメソッドが返す値は"main"です。"main"はpメソッドによって標準出力に出力されます。
    そのため、(a)が正解です。
    ```
   
1. 以下のコードを実行した出力結果として正しいものを選択肢の中から選択してください。
    
    ```
    a = "foo"
    b = a
    b.slice!(0, 1)
    print(a, b)
   
    選択肢
    (a) “foofoo”
    (b) “ff”
    (c) “fofo”
    (d) “oooo”
   
    #=> (d) "oooo"
    sliceメソッドを呼び出しているローカル変数のbに代入している"foo"は、0の位置の"f"から1バイトの範囲を取り除きます。
    そのため、"foo"から"oo"になります。ローカル変数のaとbはどちらも同じオブジェクトを代入しています。
    slice!メソッドでローカル変数のbに代入していた"foo"が"oo"になると、ローカル変数のaも"oo"になります。
    それらのローカル変数を引数に指定したprintメソッドは、そのまま"oooo"を標準出力へ出力します。
    正解は(c)です。
    ```

1. 以下のプログラムの実行結果はどれでしょうか。
    
    ```
    File.open("hats.txt", "w") do |f|
      f.puts(%w[Bowler Deerstalker Dunce\ cap Fedora Fez])
    end
     
    File.open("hats.txt") do |f|
      4.times { f.gets() }
      puts f.gets
      puts f.readline
    end
   
    選択肢
    (a) 標準出力に"Fez\n"を出力した後、"nil"を出力する
    (b) 標準出力に"Fez\n"を出力した後、"Bowler\n"を出力する
    (c) 標準出力に"Fedora\n"を出力した後、"Fez\n"を出力する
    (d) 標準出力に"Fez\n"を出力した後、EOFError例外が発生して処理が終了する
   
    #=> (d) 標準出力に"Fez\n"を出力した後、EOFError例外が発生して処理が終了する
    IOオブジェクト(ストリーム)を使用する時、Rubyはストリームでデータを読み込むか、または次のデータを挿入するべきかレコードを維持しています。ファイルは最初に開かれると、レコードがファイルの先頭を指すように設定されています。getsメソッドかreadlineメソッドを呼び出した時、これらは(この場合はFileオブジェクトが)ストリームから行を読み込み、そして次の行の先頭を指すようにレコードを設定します。
    
    したがって、問題のプログラムでは、レコードは"hats.txt"の最初の行を最初に指します。それから、getsメソッドを4回呼び出した後、5行目を指します。
    “puts f.gets”は5行目を読み込むので、標準出力に内容を書き込むのとレコードにファイルの最後である次の行を指すように設定します。レコードがファイルの末尾(EOF)を指している時に、readlineメソッドを呼び出すと(“puts f.readline”を実行している場合)EOFError例外を発生します。
    
    現にgetsメソッドとreadlineメソッドはEOFに反応するということのみ異なります。getsメソッドはnilを返しますが、readlineメソッドはEOFError例外を発生します。
    
    %w[ element1 element2 ]のようなリテラルは文字列の配列を指定します。文字列の要素は半角スペース区切りの単語のリストとして指定されています。プログラムの最初の3行は、行区切りの帽子の型のリストを内容に含む"hats.txt"が作成します。
    ```
   
1. 次に示す内容を持つファイルの"authors.txt"があるとすると、以下のプログラムの出力は何でしょうか。
    
    ```
    Authors.txt:
    
    Kawabata
    Hemingway
    Kafka
    
    File.open("authors.txt") do |file|
      2.times { file.gets }
      file.lineno = 0
      puts file.gets
    end
    
    選択肢
    (a) nil
    (b) Kafka
    (c) Kawabata
    (d) Hemingway
   
    #=> (b) Kafka
    Fileオブジェクトを操作している時、Rubyは次に読み込むか、またはデータを挿入するべきかレコードを維持します。ファイルが最初に開かれると、レコードはファイルの先頭を指し示すように設定されます。getsメソッドが呼び出される度、レコードは次の行の先頭に設定されます。
    この問題のプログラムでは、2回呼び出されたgetsメソッドはファイルの3行目の"Kafka"にレコードを設定します。
    次に、File#lineno=は引数としての数値の0と一緒に呼び出されます。一見したところ、ファイルの最初の行から次のgetsメソッドの呼び出しをおこなうように見えるかもしれません。ただし、そのようにlineno=が動作するということはありません。linenoの値は何回getsメソッドが呼び出されたかを記録しますが、ファイルの指定した行に直接対応していないので、次の読み込み、または書き込みのために位置を設定するのに使うことはできません。
    したがって、レコードはファイルの3行目を指しているのを維持するので、次のgetsの呼び出しは"Kafka"の文字を返す。
    ※ File#lineno=の代わりに、File#rewindメソッドはファイルの先頭の行の位置にレコードを設定するのに使うことができます。
    ```

1. 4つの選択肢のうち、以下のプログラムを実行した後に返すものとして正しいのはどれでしょうか。
   
    ```
    file = File.open("hello.rb", "w")
    stat = file.stat
    mtime1 = stat.mtime
    file.puts("new data")
    file.flush
    mtime2 = stat.mtime
   
    選択肢
    (a) file.mtimeは変更されない。
    (b) mtime1 == mtime2
    (c) mtime1 > mtime2
    (d) mtime1 < mtime2
    
    #=> (b) mtime1 == mtime2
    インスタンスメソッドのFile#statはタイムスタンプ、著作者､アクセス許可などに関する基本的なメタデータを保有しているFile::Statオブジェクトを取得します。File::Stat#mtimeはファイルが最後に変更された時間を表しているTimeオブジェクトを返します。
    
    File::Statオブジェクトはオブジェクトを作成した時のファイルの状態のスナップショットということと、ファイルの内容が変更された場合、スナップショットは自動的に変更されないということに注意してください。
    
    その結果、File::Statオブジェクトはf.flushメソッドの呼び出しでファイルに新しいデータを書き込んだ後も変更されないまま変数のstatが格納しているので、stat.mtimeの返す値は変更しないまま呼び出されます。つまりmtime1とmtime2は同一のTimeオブジェクトを格納しています。
    
    オプション(d)のように、インスタンスメソッドのFile#mtimeメソッドの呼出しは、File::Stat#mtimeの場合のように値をキャッシュしないで現在のファイルの最終更新時間を返します。これはfile.mtimeの戻り値が実際に変更していないということを意味するので、(d)の選択肢は間違いになります。
    ```

1. "tmp"ディレクトリが現在の作業ディレクトリに存在していないと考えた場合、どのぐらい"rocking.rb"ファイルが以下のプログラムを実行しているあいだに作成されるでしょうか。そして実行終了後にどのぐらい残っているでしょうか。
    
    ```
    ["tmp", "tmp/lang",  "tmp/lang/ruby", "tmp/lang/python"].each do |dir|
      Dir.mkdir(dir)
    end
    Dir.chdir("tmp/lang")
    Dir.new(".").each do |entry|
      filename = File.join(entry, "rocking.rb")
      File.open(filename, "w")
    end
    Dir.rmdir("python")
   
    選択肢
    (a) 2つ作成して、1つ残る
    (b) 2つ作成して、2つ残る
    (c) 4つ作成して、3つ残る
    (d) 4つ作成して, 4つ残る
   
    #=> (d) 4つ作成して, 4つ残る
    Dir.mkdirは"tmp"ディレクトリを作成する2つの繰り返しの最初に呼び出した後、"tmp"の中に"lang"というサブディレクトリを作成して、最後に"lang"の中に"ruby"と"python"という2つのディレクトリを作成することに進みます。
    Dir.chdir(“tmp/lang”)は単純に作業ディレクトリを変更します。
    2番目の繰り返しの中で使われたDir#eachメソッドは、ブロックに付属の引数としてディレクトリの中で各エントリを渡します。
    このディレクトリオブジェクトが表している".“は、現在の作業ディレクトリです。
    ここで注意する重要なことは、ブロックに渡される値でディレクトリ名の”ruby"と"python"ではない".“と”.."が含まれていることで、言い換えると、現在の作業ディレクトリ、それと親ディレクトリです。
    つまり2番目のブロックに4つの値が渡されたということなので、合計4つのファイルがFile.openによって作成されます。    
    最後に、Dir.rmdirは"Directory not empty – python (Errno::ENOTEMPTY)"という例外を発生して失敗します。rmdirメソッドは空でないディレクトリを削除することはできません。
    ※ Dir.mkdirを使用して新しいディレクトリを作成する時、パスまでの(tmp/lang/rubyと同じように)ディレクトリ名を付加することが可能で、これによって現在の作業ディレクトリ以外で作成されたディレクトリを持っています。だから、付加したパスのディレクトリは既に存在するものでなければ、mkdirメソッドで自動的に作成できません。
    ```
   
1. 以下で示すプログラムが返す出力結果として正しいものを1つ選択してください。
    
    ```
    foo = ('a'..'z').each_with_index {|i, n| break(i) if n.odd? }
    p foo.succ
   
    選択肢
    (a) NoMethodError例外が発生する。
    (b) (‘a’..‘z’)
    (c) “b”
    (d) “c”

    #=> (d) "c"
    
    範囲オブジェクトの..は始端から終端までの範囲を表します。(‘a’..‘z’)は文字列オブジェクトの’a’から’z’までの範囲を表している範囲オブジェクトです。
    each_with_indexメソッドはレシーバに指定した要素の集まりから、要素を取り出してインデックスと一緒にブロックに渡して操作することができます。問題のブロックパラメータの名前では、iが要素でnがインデックスです。
    odd?メソッドはレシーバに指定した数値オブジェクトの値が奇数であるかを評価して真偽値を返します。i.odd?はeach_with_indexメソッドによって渡されたインデックスが奇数であるかを判定しています。インデックスが奇数ならばodd?メソッドが真の値を返して、if修飾子で指定されたbreak(i)が実行されます。
    breakメソッドがブロックの中で呼び出されると、ブロックの繰り返しを終了します。breakメソッドの引数が指定されていれば、その値がブロック付きメソッド呼出しの返す値になります。インデックスは0から数え始め、最初に奇数になるインデックスは1です。each_with_indexメソッドはインデックスが1の値である"b"を返して繰り返しを終えます。そして、返された"b"はローカル変数のfooに代入されます。
    ローカル変数のfooに代入された"b"は、succメソッドを呼び出しています。文字列オブジェクトのsuccメソッドは、レシーバに指定した文字列オブジェクトがアルファベットの文字であった場合、次のアルファベットの文字列オブジェクトを新しく生成して返します。bの次のアルファベットはcなので、pメソッドが標準出力に出力するのは"c"です。
    そのため、(d)が正解です。
    ```

1. ソースコードの文字コードをUS-ASCIIに設定するマジックコメントの書き方として正しいものを全て選択してください。

    ```
    選択肢
    (a) # coding: us-ascii
    (b) # encoding: us-ascii
    (c) # -*- charset: us-ascii -*-
    (d) # CODING: US-ASCII
   
    #=> (a),(b),(c)
    マジックコメントは「coding: エンコーディング名」が正しければ、その前後には任意の文字を並べることができます。
    また、大文字・小文字の区別もありません。
    ```

1. 以下のコードを実行するとどうなりますか。正しいものを全て選択してください。
    
    ```
    begin
        puts 1+"2"
    rescue
        puts "Error."
    rescue TypeError
        puts "Type Error."
    ensure
        puts "Ensure."
    end
   
    選択肢
    (a) 3と表示される
    (b) Error.と表示される。
    (c) Type Error.と表示される。
    (d) Ensure.と表示される。
    
    #=> (b),(d)
    rescue節において例外型を省略すると、StandardErrorとそのサブクラス例外を捕捉します。2行目で発生するTypeErrorはStandardErrorのサブクラスなので、
    3~4行目のrescue節で処理されます。また、ensure節は必ず実行されるため、7~8行目が処理されます。
    ```

1. 以下のコードを実行するとどうなりますか。

    ```
    def foo(*a)
        p a
    end
    foo(1,2,3)
   
    選択肢
    (a) ["1","2","3"]
    (b) [1,2,3]
    (c) 文法エラーになる。
    (d) 例外が発生する。
    
    #=> (b)
    メソッドの引数に*を付けると、可変長引数として扱われ、メソッドには任意の個数の引数を渡せるようになり、
    結果は配列に格納されます。fooメソッドには1,2,3の引数が渡されているため、aには[1,2,3]が入ります。
    ```

1. 以下のメソッドは縁の面積を求めるコードですが、このままでは動きません。このコードを動かすための修正方法として適切な選択肢を2つ選びなさい。
   ただし、各選択肢は独立しており、その修正のみを実行すれば動作します。
   
   ```
   def area r
    return r * r * PI 
   end
   
   選択肢
   (a) メソッド定義の上にinclude Mathと記述する。
   (b) メソッド定義の上にrequire "Math"と記述する。
   (c) メソッド定義の上にrequire Mathと記述する。
   (d) PIの前にMath.と記述する。
   (e) PIの前にMath::と記述する。
   (f) PIをMath(PI)と書き換える。
   
   #=> (a),(e)
   定数PIはMathモジュールに定義されています。従って、PIを使うにはMathモジュールをincludeするか、
   Math::PIとしてPIのモジュールを明示的に宣言します。
   ```

1. オーバーライド（再定義）不可の演算子を2つ選びなさい。
    
   ```
   (a) +
   (b) ..
   (c) %
   (d) &
   (e) &&
   (f) ==
   
   #=> (b),(e)
   以下の演算子はオーバーライドできません。
   = ?: .. ... not && and || or ::
   他に、自己代入演算子(+=)などもオーバーライドできません。
   ```

1. Hashクラスのメソッドの説明として適切ではない記述を選びなさい。

    ```
    (a) deleteはキーを指定してキーと値の組みを削除する
    (b) removeはキーと値の組を削除する
    (c) fetchは与えられたキーに関連付けられた値を返す
    (d) clearはハッシュの要素を全て削除する
    
    #=> (b)
    Hashクラスにメソッドremoveは定義されていません。
    ```
   
1. 以下のコードを実行するとどうなりますか。

    ```
    ファイルdataの内容
    abcdefg
    
    File.open("data") do |io|
        while not io.eof?
            print io.read(1)
            io.seek(0,IO::SEEK_SET)
        end
    end
   
    選択肢
    (a) abcdefgと表示される
    (b) aが表示され続ける
    (c) zが表示され続ける
    (d) 何も表示されない
    (e) 実行時エラー
   
    #=> (b)
    4行目のio.seek(0,IO::SEEK_SET)は、ファイルポインタを先頭に移動します。
    従って出題コードは、ファイルdataの先頭文字aを読んで表示する処理を繰り返します。
    ```

1. 以下のコードを実行したときの出力として適切な物を1つ選択してください。

    ```
    str = "RubyAssociation\r\n".chop
    
    選択肢
    A."RubyAssociation"
    B."RubyAssociation\r"
    C."RubyAssociation\r\n"
    D."RubyAssociation\r\n\r\n"
    
    #=> A
    String#chopは文字列末尾の文字を1文字削除するためのメソッド。
    String#chompが改行文字を対象するのに対しchopはすべての文字を対象とする。
    ただし、文字列末尾が\r\nの場合は、2文字とも削除します。
    String#chop!はレシーバーの文字列自体を変更する破壊的メソッドです。
    ```