# よく間違える問題

1. 下記コードの実行結果として正しい組み合わせを選択肢の中から選べ。

    ```
    0x65.chr(Encoding::UTF_8)
    => "e"
   
    chrメソッドは文字コードに対応する文字を求めるメソッド。
    0x65.chrは"e"となるが65.chrは"A"となる点に注意。
    ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   cooking = "Rice\nBread\rPasta\n\r"
   p cooking.chomp
   => "Rice\nBread\rPasta\n"
   
   chompメソッドは、末尾から指定した文字列（指定がなければ改行コード"\r", "\r\n", "\n"）を取り除いた文字列を返す。
   ここでは、末尾が"\r\n"ではなく、"\n\r"なので、末尾の"\r"のみが取り除かれる。
   ```

1. 下記コードの実行結果を、選択肢の中から選べ。
   
   ```
   ef.downto(ab){|s| print(s)}
   => エラーになる
   
   downtoメソッドは文字列に使用するとエラーになる。
   数値や日付などに使用可能。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   pass = [8, 9, 2, 1] | [2, 7, 4, 1].sort
   p pass
   => [8, 9, 2, 1, 4, 7]
   
   sortメソッドは、配列の内容をソートする。今回は[2, 7, 4, 1].sortのみがソートされ、
   [8, 9, 2, 1] | [1, 2, 4, 7]となる。
   その後、パイプ演算子によって、重複排除されるため、[8, 9, 2, 1, 4, 7]となる。
   ```

1. 下記コードの実行結果を、選択肢の中から選べ。
   
   ```
   i = 10.upto(20).reject {|d| d >= 15 }
   print i
   => [10, 11, 12, 13, 14]
   
   rejectメソッドはブロックを評価した結果が偽である要素を含む配列を返す。
   今回は、10~20の間で、15以上でない数字[10, 11, 12, 13, 14]が配列として返る。
   逆に、selectメソッドにした場合は、評価した結果が真である要素を含む配列を返すため、
   [15, 16, 17, 18, 19, 20]が返る。
   ```

1. File.openのmodeについて正しい説明をしている選択肢を選べ。
   
   ```
   => "a"は書き込み専用。ファイルが存在しない場合、新規作成する。
   File.openメソッドでファイルを開く。
   引数でファイルを開くモードを設定できる。
   
   "r"・・・read 読み込みモード。
   "w"・・・write　書き込みモード。既存ファイルの場合はファイルの内容を空にする。
   "a"・・・append　追記モード。常にファイルの末尾に追加される。
   "r+"・・・読み書きモード。ファイルの読み書き位置は先頭にセットされる。
   "w+"・・・読み書きモード。既存ファイルの場合はファイルの内容を空にする。
   "a+"・・・読み書きモード。ファイルの読み込み位置は先頭にセットされるが、書き込みは常にファイルの末尾に追加される。
   ```

1. 下記コードを実行した際の戻り値を選べ。
   
   ```
   id = [1, 2, 3, 4, 5]
   p id.delete(3)
   => 3
   
   deleteメソッドは指定された値と==メソッドで等しい値があれば全て取り除いて、その値を返す。
   取り除いた配列を返すわけではないので注意！
   なければnilを返す。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   h = {:name => 'sato', :club => 'tennis'}.fetch(:name, 'error')
   print h
   => sato
   
   fetchメソッドは与えられたキーに対する値を返す。
   今回はnameがキーとなる値 'sato'を返す。
   2番目の引数に指定されている 'error'は該当するキーがない場合の返り値となる。今回はキーがあるため、ひっかけなので注意。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   （１）p sprintf("%#b", 20)
   （２）p sprintf("%#o", 20)
   （３）p sprintf("%#x", 20)
   => （１）"0b10100"（２）"024"（３）"0x14"
   
   組み込み関数sprintfでフォーマットの指定ができる。
   第一引数でフォーマット、第二引数でフォーマットしたい値を指定する。
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   a = ["fire", "water", "wind"]
   b = a.clone
   c = a
   a.concat(["metal"])
   
   （１）a == b
   （２）a == c
   => （１）false （２）true
   
   a = ["fire", "water", "wind"]
   b = a.clone  
   # この時点で b = ["fire", "water", "wind"]
   c = a
   # この時点で c = ["fire", "water", "wind"]
   a.concat(["metal"])
   # この時点で a = ["fire", "water", "wind", "metal"]
   # 同時に c = ["fire", "water", "wind", "metal"] に変わる。
   
   評価前のa,b,c各変数の要素を整理すると以下となる。
   a = ["fire", "water", "wind", "metal"]
   b = ["fire", "water", "wind"]
   c = ["fire", "water", "wind", "metal"]
   
   よって、結果は以下となる。
   a == b # false
   a == c # true
   ```

1. 戻り値が「Object」以外となるコードを選択肢の中から選べ。
   
   ```
   => puts Integer.superclass # Numeric となる
   
   superclassメソッドを使うことで、継承元のクラスを確認できる。
   String, Array, HashはObjectクラスを継承しているが、
   IntegerとFloatはNumericクラスという数値を表現するクラスを継承している。
   
   Integer.superclass # Numeric
   Float.superclass # Numeric
   String.superclass # Object
   Array.superclass # Object
   Hash.superclass # Object
   ```

1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   Curry = "udon"
   Curry << "rice"
   p Curry
   => 警告は出ず、"udonrice"と出力される。
   
   定数を再代入するときは警告が出るが、<<メソッドで連結するときは警告は出ないので注意！
   ```
   
1. includeの説明として正しいものを選択肢の中から選べ。
   
   ```
   => Moduleクラスのメソッドである
   
   includeメソッドを使用することで、生成したモジュールオブジェクトをクラスに取り込むことができる。
   ```
 
 1. 例外処理の説明として誤っているものを選択肢の中から選べ。
    
    ```
    def exam
      begin
        （１）例外が発生する可能性のある処理
      rescue 
        （２）例外が発生した場合の処理
      else
        （３）正常の処理
      ensure
        （４）例外発生の有無にかかわらず行う処理
      end
    end
    => （３）にraiseを記入することで、強制的に例外を発生させることができる。
    
    raiseで例外を発生させることができるが、（１）の箇所で例外を発生させるべきである。
    ```
    
 1. 下記コードを実行した結果、エラーが発生するものを選べ。
    
    ```
    => meibo = {:Name => Sato, :Class => 1-1, :ID => 1}
    
    値であるSatoを""（ダブルクォーテーション）で囲んでいないのでエラーとなる。
    ```

1. 下記コードを実行した際の戻り値を選べ。
   
   ```
   singer=["shintani", "kamiya"]
   p singer.shift
   => "shintani"
   
   shiftメソッドは先頭から指定された数だけ要素を取り除いて返す。指定がなければ先頭の要素を返す。
   取り除かれた後の配列ではなく、取り除かれた要素の値を返すので注意！
   ```
   
1. 下記コードの実行結果を選択肢の中から選べ。
   
   ```
   a = "victory"
   b = "victory"
   c = a
   
   （１）p a.eql?(b)
   （２）p a.eql?(c)
   （３）p a.equal?(b)
   （４）p a.equal?(c)
   正解: （１）true （２）true （３）false （４）true
   
   eql?メソッドとequal?メソッドの違いの問題。
   eql?メソッドは同値性を判定。値と型が等しければtrueを返し、異なればfalseを返す。
   equal?メソッドは同一性を判定。2つのオブジェクトが同一かどうかを判定し、等しければtrue, 異なればfalseを返す。
   ```

1. Rubyの予約語として適切な物を選びなさい。（２つ選択）

    ```
    1. while
    2. rand
    3. goto
    4. class
    5. const
    
    正解: 1,4
    Rubyの予約語・・・while, class
    それ以外・・・rand, goto, const 
    ```

1. 以下のコードを実行するとどうなりますか？
    
    ```
    x = 0
    [1,2,3].each do |x|
        print x.to_s + " "
    end
    puts x
    
    => 1,2,3,0
    1行目の宣言している変数xとeachブロックの変数xはスコープが異なるため、別の変数として扱われる。
    ```

1. 以下のコードを実行するとどうなりますか？最も適切な記述を選びなさい。

    ```
    HOGE = "hoge"
    HOGE.gsub!("hoge", "piyo")
    print HOGE
    
    #=> 警告は発生せず、「piyo」が表示される
    HOGEは定数だが、警告が発生するのは、新たに代入するときのみ。
    ここでは破壊的メソッドを呼び出しているだけなので、警告は発生しない。
    ```

1. 以下のコードのxに、ZeroDivisionErrorが発生した時の処理を記述したい。適切なコードを選びなさい。

    ```
    begin
        puts 10 / 0 #ZeroDivisionError
        x
        print "ZeroDivisionException:", ex.message
    end
    
    結果： ZeroDivisionException:divided by 0
    
    #=> rescue ZeroDivisionError => ex 
    rescue節は、rescue【例外型】=>【例外変数】と記述します。
    begn節で【例外型】の例外が発生した場合、【例外変数】には例外オブジェクトへの参照が渡され、処理される。
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを選びなさい。

    ```
    s = "a;b:c;d:e;f"
    p s.split(x)
    
    結果： ["a", "b", "c", "d", "e", "f"]
    
    #=> /:|;/
    String#splitは引数で指定された正規表現などで文字列を分割し、配列に格納する。
    正規表現はスラッシュでパターンを囲む。スラッシュの前後にダブルクォーテーションは付かないので注意！
    ```

1. 以下のコードの実行結果として適切なものを選びなさい。
    
    ```
    a = [1,2,3,4]
    b = [1,3,5,7]
    
    p a || b
    
    #=> [1,2,3,4]
    演算子||は、真であるオペランドの値を返す。
    左オペランドの評価結果が真の場合は、右オペランドを評価せずに左オペランドの値を返す。
    今回はnilでもfalseでもないので、左オペランド部が真となるため、値[1,2,3,4]を返す。
    ```

1. 以下のコードの実行結果として適切な物を選びなさい。
    
    ```
    a = [:a, :a, :b, :c]
    a[5] = :e
    a.concat([:a, :b, :c])
    a.compact
    a.uniq
    p a
   
    #=> [:a, :a, :b, :c, nil, :e, :a, :b, :c]
    Array#concatは配列を連結する。
    compactはnil要素を削除する。
    uniqは重複している要素を削除する。
    ただし、compactとuniqは**非破壊的メソッド**なのでオブジェクトの値は変更しない。
    ```

1. Arrayクラスでdetectと同じ動作をするメソッドを選びなさい。
    
    ```
    #=> find
    detectとfindは各要素に対してブロックを評価し、真になった最初の要素を返す。
    # 最初の 3 の倍数を探す
    p [1, 2, 3, 4, 5].find {|i| i % 3 == 0 }   # => 3
    p [2, 2, 2, 2, 2].find {|i| i % 3 == 0 }   # => nil
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを**全て**選びなさい。
    
    ```
    a = ["a", "b", "c"]
    b = [1, 2, 3]
    x
   
    結果： ["a", 1]
          ["b", 2]
          ["c", 3]
   
    #=> a.zip(b).each{|x| p x}
        a.zip(b){|x| p x}
        [a, b].transpose.each{|x, y| p [x, y]}
        
        Array#zipは自身と引数に渡した配列の各要素からなる配列を生成して返す。
        ブロックを渡した場合は、各要素を順番に返す。
        Array#transposeは2次元配列の行と列を入れ替えるメソッド。
    ```

1. 以下のコードの実行結果として適切な物を選びなさい。
    
    ```
    x = "Hello, World.\n"
    x.chop
    x.chop
    x.chomp
    p x
    
    #=> "Hello, World.\n"
    String#chopは末尾の1文字を削除する。
    String#chompは末尾が行区切り文字であれば削除する。
    今回は、どちらも**非破壊的メソッド**なので、元の文字列は変更しない。 
    ```

1. 以下のコードを実行すると何が表示されますか？
    
    ```
    puts "0123456789-".delete("^13-56-")
    
    #=> 13456-
    String#deleteは、引数に含まれる文字を文字列から取り除く。
    ^で始まる文字列は、その文字列以外を削除する。
    deleteメソッドは削除する文字列を返す。 
    ```

1. 以下のコードを実行すると何が表示されますか？
    
    ```
    p "abc def 123 ghi 456".scan(/\d+/).length
    
    #=> 2
    String#scanは正規表現にマッチする部分文字列を配列で返す。
    \d+は数字の繰り返し。
    ```

1. 以下のコードを実行するとどうなりますか。
    
    ```
    h = {"a": 1, "b": 2, "c": 3}
    p h
    
    #=> 文法エラーになる
    Ruby2.1ではキーの部分を文字列リテラルで表記することはできず、文法エラーになる。
    Ruby2.2からはこの書き方でハッシュを生成できる。
    ```

1. 以下のコードを実行すると何が表示されますか。
    
    ```
    a = {"Foo" => "Hoge", "Bar" => "piyo", "Baz" => "Fuga"}
    b = {"Foo" => "hoge", "Bar" => "piyo", "Baz" => "fuga"}
    
    p a.update(b).sort{|a, b| a[1] <=> b[1]}
   
    #=> [["Baz", "fuga"], ["Foo", "hoge"], ["Bar", "piyo"]]
    Hash#updateメソッドは、自分自身のHashと引数に指定したHashを統合する。
    そのため、4行目直後の状態は{"Foo" => "hoge", "Bar" => "piyo", "Baz" => "fuga"}となる。
    sortメソッドのブロック内のa[1] <=> b[1]はHashの各ペア（[キー、値]）を値の昇順に並べるので、
    [["Baz", "fuga"], ["Foo", "hoge"], ["Bar", "piyo"]]になる。
    ```
   
1. 以下のコードは、ファイルtest.txtを読み、文字を逆順に書き込む処理です。xに入る適切な記述を選びなさい。
    
    ```
    open("test.txt"," x ") do |f|
        data = f.read.chomp
        data.reverse!
        f.rewind
        f.write data
    end
    
    #=> r+
    組み込み関数openの第2引数でファイルのopenモードを指定する。
    r,w,aに+を付けると、読み書き両用でオープンする。w+に指定すると元のファイルの内容を空にする。
    a+を指定すると、追記モードになる。
    ```

1. 以下の実行結果になるように、xに記述する適切なコードを選びなさい。

    ```
    puts File. x ("/","user","bin")
   
    結果： /user/bin
    
    #=> join
    joinはスラッシュを間に入れて引数の文字列を連結したファイルパスを作成する。
    ```