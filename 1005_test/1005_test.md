# Ruby技術者認定試験 基礎力確認問題 2020/10/5 実施

1. 文法(マジックコメント)
    - スクリプトファイルの1行めに書かれたコメントはマジックコメントという。
    - スクリプトエンコーディングを伝える役割がある。
    - 以下のように様々な書き方がある。

    ```
    # coding: euc-jp
    # -*- coding: euc-jp -*-
    ```

1. 文法(変数のスコープ)
    - メソッド内とメソッド外では変数名が同じでも別の変数として扱われる。
    - メソッド内の変数xは定義されていないため、例外(エラー)が発生する。

1. 文法(例外処理)
    - rescue
        - 例外が発生した場合、rescue内の処理が実行される。
    - ensure
        - 例外の有無にかかわらず、必ず実行される。

1. 文法(整数リテラル)
    - 16真数の整数リテラル
        - 0x~
    - 8進数の整数リテラル
        - 0~
            - 8進数では各桁の最大値は8なので、選択肢の「090」という数値はありえない。

1. 文法(三項演算子)
    - 参考演算子の公式
        - 条件 ? 条件が真の場合の値 : 条件が偽の場合の値
    
    ```
    x = 10
    y = x < 10 ? "A" : "B"
    puts y
    => B
    ```

1. 文法(定数)
    - 先頭文字列がアルファベット大文字の場合は定数
        - Rubyの定数は警告が表示されるが変更することができる。

1. 文法(*可変長引数)
    - メソッドの引数に*をつけると、可変長引数として扱われ、任意の個数の引数を渡せるようになり、結果は配列に格納される。

    ```
    def foo(*a)
        p a
    end
    foo(1,2,3)
    => [1, 2, 3]
    ```

1. 文法(変数の種類と定数）
    - ローカル変数
        - アルファベット小文字か_から始まり、1文字以上で構成される。
    - グローバル変数
        - $で始まる。
        - プログラムのどこからでも参照が可能（その分、注意が必要）。
    - クラス変数
        - @@から始まる。
        - クラスの中で定義され、クラスの特異メソッド、インスタンスメソッドなどから参照/代入が可能。
    - インスタンス変数
        - @から始まる。
        - そのクラスまたはサブクラスのメソッドから参照が可能。
    - 定数
        - アルファベット大文字で始まる。
        - 一度定義された定数に再び代入を行おうとすると、警告メッセージが出る。

1. オブジェクト指向(super)
    - super
        - スーパークラスのメソッドを呼び出す。

1. オブジェクト指向(定数PIについて)
    - 定数PIはMathモジュールに定義されているため、Mathモジュールをインクルードするか、Math::PIと記述して、PIのモジュールを明示的に宣言する必要がある。

1. オブジェクト指向(オーバーライドできない演算子)
    - 以下の演算子はオーバーライド（再定義）することができない。
        - =
        - ?
        - :
        - ..
        - ...
        - not
        - &&
        - and
        - ||
        - or
        - ::

1. オブジェクト指向(特異メソッド)
    - 特異クラス
        - 指定したインスタンスだけに適用される特別なクラス
        - シングルトンクラスとも呼ばれる。
    - 特異メソッド
        - インスタンスに直接定義されたメソッド

1. 組み込みライブラリ(配列)
    - <=>（UFO演算子)
        - 配列に含まれる各要素を比較し、小さい順に並び替える。

1. 組み込みライブラリ(&演算子で共通の要素を取得する)
    - 配列の積集合を表示する
        - &演算子を使って共通要素を取得する。

1.  組み込みライブラリ(配列の負の添字)
    ```
    a = [1,2,3,4]
    a[0..-2].each do |i| print i " " end
        配列の最後の要素が-1になるので、a[0..-2]となる。
    a[0,3].each do |i| print i " " end
        カンマは、ある位置からの個数を指定する。
        添字0から3個、なので1,2,3を参照する。
    実行結果
    1 2 3
    ```

1. 組み込みライブラリ(配列で使用するメソッド)
    - find_all / select
        - {}ブロック内の式がtrueになる要素を抽出する
        ```
        # 2で割り切れるものを抽出
        [1,2,3,4,5,6].select { |n| n % 2 == 0 }
        # => [2,4,6]
        ```
    -  map / collect
        - 要素の数だけ繰り返しブロックを実行し、ブロックの戻り値を集めた配列を返す
        - ブロックの戻り値がない場合はnilを返す
        ```
        [1,1,1,2,3,4].map{ |n| n * 3 if == 1 }
        # => [3,3,3,nil,nil,nil]
        ```
    - first
        - 配列の先頭の要素を返す
        ```
        p [0,1,2].first
        # => 0
        p [].first
        # => nil
        ```
    - concat a
        - 配列aを自身の配列の末尾に**破壊的**に連結する
        ```
        array = [1, 2]
        a     = [3, 4]
        array.concat a
        p array
        # => [1, 2, 3, 4]
        p a
        # => [3, 4]
        ```

1. 組み込みライブラリ(zipメソッド)
    - zip
        - 配列の要素を引数の配列の各要素と組み合わせ、配列の配列を生成して返す。
        ```
        a1 = %w(a b)
        => ["a", "b"]
        a2 = %w(x y)
        => ["x", "y"]
        a3 = a1.zip(a2)
        => [["a", "x"], ["b", "y"]]
        p a3.first
        # => ["a", "x"]
        ```

1. 組み込みライブラリ(sliceメソッド)
    - slice
        - 指定された自身の要素を返す
        ```
        p [0,1,2].slice(0, 2)
        # => [0,1]
        p [0,1,2].slice(2..3)
        # => [2]
        
        a = [1,2,3,4,5]
        p a.slice(1,3)
        # => [2,3,4]
        ```
           
1. 組み込みライブラリ(eqlメソッド)
    - eql? // ==
        - 左辺と右辺の値が等しければtrue
    - equal?
        - 左辺と右辺のオブジェクトが同一であればtrue

1. 組み込みライブラリ(文字列オブジェクトと整数オブジェクトの演算)
    - 文字列を正の整数でかけることはエラーにならない。
    ```
    puts "Hello" * 5
    # => 
    Hello
    Hello
    Hello
    Hello
    Hello
    ```
   
1. 組み込みライブラリ(ヒアドキュメント)
    - ヒアドキュメント
        - 終端を示す識別子の直前までを文字列とみなす。
        ```
        puts <<-EOS
        foo
        bar
        baz
        EOS
        ```

1. 組み込みライブラリ(concat, chop, chompメソッド)
    - concat a
        - 文字列の末尾にaを**破壊的**に連結する
    - chop
        - 文字列の最後の文字を取り除いた新しい文字列を生成して返す
        - 文字列の終端が"\r\n"であればその2文字を取り除く
        - **非破壊的メソッド**
    - chomp
        - 文字列の終端が"\r", "\r\n", "\n" の場合全てを取り除きます。
        - **非破壊的メソッド**

1. 組み込みライブラリ(文字列)
    - 文字列に[]を使用する
        - 配列のように添字でのアクセスができる
        ```
        a = [1,2,3,4,5]
        p a[1,4]
        # => [2,3,4,5]
        ```

1. 組み込みライブラリ(文字列)
    - [文字列 % 配列]で配列の要素を文字列内の%dや%sなどに埋め込んで表示している
    ```
    member = [10, "Tanaka"]
    print "ID:%2d Name:%s" % member
    # => ID:10 Name:Tanaka
    ```
   
1. 組み込みライブラリ(Hashクラスについて)
    - Hashクラス
        - {}で空のハッシュが生成できる
        - invert
            - 値からキーへのハッシュを作成して返す
            ```
            h = { "a" => 0, "b" => 100, "c" => 200, "d" => 300, "e" => 300 }
            p h.invert   #=> {0=>"a", 100=>"b", 200=>"c", 300=>"e"}
            ```

1. 組み込みライブラリ(ハッシュクラスについて)
    - delete
        - キーを指定してキーと値の組を削除する
    - fetch
        - 与えられたキーに関連づけられた値を返す
    - clear
        - ハッシュの要素を全て削除する

1. 組み込みライブラリ(ハッシュ)
    - Hashオブジェクトを作る方法
        - {a: 1, b: 2, c: 3}
        - Hash[:a, 1, :b, 2, :c, 3]
        
1. 組み込みライブラリ(IO)
    - io.seek(0, IO::SEEK_SET)はファイルポインタを先頭に移動する

1. 組み込みライブラリ(日付)
    - strftimeメソッド
        - %Y
            - 4桁の西暦
        - %y
            - 2桁の西暦
        - %m
            - 月
        - %d
            - 日
        - %H
            - 時刻
        - %M
            - 分
        - %S
            - 秒
        ```
        t = Time.gm(1970, 1,1)
        puts t.strftime("%Y/%m/%d")
        # => 1970/01/01
        ```
      
1. 組み込みライブラリ(正規表現)
    - New or new にマッチする正規表現
        - ^[Nn]ew$
        - [Nn][e][w]$